{"ast":null,"code":"var _jsxFileName = \"/Users/gagandeep.singh/Downloads/trp-main-feature-voice-first-ui/frontend2/src/components/AudioVisualization.tsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useState, useCallback } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst AudioVisualization = ({\n  isListening,\n  isSpeaking,\n  audioLevel = 0,\n  className = '',\n  size = 300\n}) => {\n  _s();\n  const canvasRef = useRef(null);\n  const animationFrameRef = useRef(undefined);\n  const particlesRef = useRef([]);\n  const timeRef = useRef(0);\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [transitionFactor, setTransitionFactor] = useState(0);\n  const lastActiveRef = useRef(0);\n\n  // Initialize particles in a sphere formation\n  const initializeParticles = useCallback(() => {\n    const particles = [];\n    const particleCount = 250;\n    const radius = size * 0.35;\n    for (let i = 0; i < particleCount; i++) {\n      // Use fibonacci sphere for even distribution\n      const phi = Math.acos(-1 + 2 * i / particleCount);\n      const theta = Math.sqrt(particleCount * Math.PI) * phi;\n      const x = radius * Math.cos(theta) * Math.sin(phi);\n      const y = radius * Math.sin(theta) * Math.sin(phi);\n      const z = radius * Math.cos(phi);\n\n      // Create varied particle sizes\n      let particleSize;\n      const sizeRandom = Math.random();\n      if (sizeRandom < 0.6) {\n        particleSize = Math.random() * 1.5 + 0.5;\n      } else {\n        particleSize = Math.random() * 2 + 2;\n      }\n      particles.push({\n        x,\n        y,\n        z,\n        originalX: x,\n        originalY: y,\n        originalZ: z,\n        targetX: x,\n        targetY: y,\n        targetZ: z,\n        size: particleSize,\n        opacity: Math.random() * 0.7 + 0.3,\n        phase: Math.random() * Math.PI * 2,\n        speed: Math.random() * 0.02 + 0.01\n      });\n    }\n    particlesRef.current = particles;\n    setIsInitialized(true);\n  }, [size]);\n\n  // Get color based on state with smooth interpolation\n  const getParticleColor = (state, opacity, transitionFactor) => {\n    const idleColor = {\n      r: 59,\n      g: 130,\n      b: 246\n    }; // Blue\n    const listeningColor = {\n      r: 59,\n      g: 130,\n      b: 246\n    }; // Blue\n    const speakingColor = {\n      r: 20,\n      g: 184,\n      b: 166\n    }; // Teal\n\n    let targetColor = idleColor;\n    if (state === 'listening') {\n      targetColor = listeningColor;\n    } else if (state === 'speaking') {\n      targetColor = speakingColor;\n    }\n\n    // Smooth color interpolation\n    const r = Math.round(idleColor.r + (targetColor.r - idleColor.r) * transitionFactor);\n    const g = Math.round(idleColor.g + (targetColor.g - idleColor.g) * transitionFactor);\n    const b = Math.round(idleColor.b + (targetColor.b - idleColor.b) * transitionFactor);\n    return `rgba(${r}, ${g}, ${b}, ${opacity})`;\n  };\n\n  // Animation loop\n  const animate = useCallback(() => {\n    const canvas = canvasRef.current;\n    if (!canvas || !isInitialized) return;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n    timeRef.current += 0.016; // ~60fps\n\n    // Clear canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Use CSS size for calculations\n    const centerX = size / 2;\n    const centerY = size / 2;\n\n    // Smooth transition logic\n    const isCurrentlyActive = isListening || isSpeaking;\n    if (isCurrentlyActive) {\n      lastActiveRef.current = timeRef.current;\n    }\n\n    // Calculate smooth transition factor\n    const timeSinceActive = timeRef.current - lastActiveRef.current;\n    const fadeOutDuration = 1.5;\n    let targetTransition = isCurrentlyActive ? 1 : Math.max(0, 1 - timeSinceActive / fadeOutDuration);\n\n    // Smooth interpolation towards target\n    const transitionSpeed = 0.05;\n    setTransitionFactor(prev => prev + (targetTransition - prev) * transitionSpeed);\n\n    // Determine base state for color mixing\n    let primaryState = 'idle';\n    if (isSpeaking) primaryState = 'speaking';else if (isListening || transitionFactor > 0.1) primaryState = 'listening';\n\n    // Animation parameters based on transition\n    const baseRadius = size * 0.35;\n    const radiusMultiplier = 1 + audioLevel * 0.3 * transitionFactor;\n    const breathingEffect = Math.sin(timeRef.current * 2) * 0.05 + 1;\n    const particleScale = primaryState === 'speaking' ? 1 + 0.5 * transitionFactor : 1;\n    particlesRef.current.forEach((particle, index) => {\n      // Update particle position based on state\n      let targetRadius = baseRadius * radiusMultiplier * breathingEffect;\n      if (primaryState === 'speaking') {\n        // Add wave effect for speaking\n        const waveOffset = Math.sin(timeRef.current * 3 + index * 0.1) * 20 * transitionFactor;\n        targetRadius += waveOffset;\n      } else if (primaryState === 'listening') {\n        // Add gentle pulsing for listening\n        const pulseOffset = Math.sin(timeRef.current * 4 + particle.phase) * 10 * transitionFactor;\n        targetRadius += pulseOffset;\n      }\n\n      // Calculate target position\n      const normalizedRadius = Math.sqrt(particle.originalX ** 2 + particle.originalY ** 2 + particle.originalZ ** 2);\n      const scale = targetRadius / normalizedRadius;\n      particle.targetX = particle.originalX * scale;\n      particle.targetY = particle.originalY * scale;\n      particle.targetZ = particle.originalZ * scale;\n\n      // Smooth interpolation to target position\n      const lerpSpeed = 0.08;\n      particle.x += (particle.targetX - particle.x) * lerpSpeed;\n      particle.y += (particle.targetY - particle.y) * lerpSpeed;\n      particle.z += (particle.targetZ - particle.z) * lerpSpeed;\n\n      // Update particle properties\n      particle.phase += particle.speed;\n\n      // Keep consistent opacity\n      let particleOpacity = particle.opacity;\n      if (primaryState === 'listening') {\n        particleOpacity *= Math.sin(particle.phase) * 0.2 + 0.8;\n      } else if (primaryState === 'speaking') {\n        particleOpacity *= Math.sin(particle.phase * 2) * 0.3 + 0.7;\n      }\n\n      // 3D to 2D projection\n      const perspective = 400;\n      const scale3D = perspective / (perspective + particle.z);\n      const x2D = centerX + particle.x * scale3D;\n      const y2D = centerY + particle.y * scale3D;\n\n      // Draw particle\n      const particleSize = particle.size * scale3D * particleScale;\n      const color = getParticleColor(primaryState, particleOpacity, transitionFactor);\n      ctx.beginPath();\n      ctx.arc(x2D, y2D, particleSize, 0, Math.PI * 2);\n      ctx.fillStyle = color;\n      ctx.fill();\n\n      // Add glow effect for active states\n      if (primaryState !== 'idle' && transitionFactor > 0.1) {\n        ctx.beginPath();\n        ctx.arc(x2D, y2D, particleSize * 2, 0, Math.PI * 2);\n        ctx.fillStyle = getParticleColor(primaryState, particleOpacity * 0.1, transitionFactor);\n        ctx.fill();\n      }\n    });\n    animationFrameRef.current = requestAnimationFrame(animate);\n  }, [isInitialized, isListening, isSpeaking, audioLevel, size]);\n\n  // Setup high-DPI canvas\n  const setupCanvas = useCallback(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    // Get device pixel ratio for crisp rendering\n    const dpr = window.devicePixelRatio || 1;\n\n    // Set actual canvas size\n    canvas.width = size * dpr;\n    canvas.height = size * dpr;\n\n    // Scale context for high DPI\n    ctx.scale(dpr, dpr);\n\n    // Set CSS size\n    canvas.style.width = `${size}px`;\n    canvas.style.height = `${size}px`;\n\n    // Enable anti-aliasing\n    ctx.imageSmoothingEnabled = true;\n    ctx.imageSmoothingQuality = 'high';\n  }, [size]);\n\n  // Initialize and start animation\n  useEffect(() => {\n    setupCanvas();\n    initializeParticles();\n  }, [setupCanvas, initializeParticles]);\n  useEffect(() => {\n    if (isInitialized) {\n      animate();\n    }\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [isInitialized, animate]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: `flex items-center justify-center ${className}`,\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        background: 'transparent',\n        borderRadius: '50%',\n        filter: 'drop-shadow(0 10px 20px rgba(0, 0, 0, 0.3))'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 269,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 268,\n    columnNumber: 5\n  }, this);\n};\n_s(AudioVisualization, \"UHHQTTPUMB2Cw/jI9pbxZ/8dfjs=\");\n_c = AudioVisualization;\nexport default AudioVisualization;\nvar _c;\n$RefreshReg$(_c, \"AudioVisualization\");","map":{"version":3,"names":["React","useRef","useEffect","useState","useCallback","jsxDEV","_jsxDEV","AudioVisualization","isListening","isSpeaking","audioLevel","className","size","_s","canvasRef","animationFrameRef","undefined","particlesRef","timeRef","isInitialized","setIsInitialized","transitionFactor","setTransitionFactor","lastActiveRef","initializeParticles","particles","particleCount","radius","i","phi","Math","acos","theta","sqrt","PI","x","cos","sin","y","z","particleSize","sizeRandom","random","push","originalX","originalY","originalZ","targetX","targetY","targetZ","opacity","phase","speed","current","getParticleColor","state","idleColor","r","g","b","listeningColor","speakingColor","targetColor","round","animate","canvas","ctx","getContext","clearRect","width","height","centerX","centerY","isCurrentlyActive","timeSinceActive","fadeOutDuration","targetTransition","max","transitionSpeed","prev","primaryState","baseRadius","radiusMultiplier","breathingEffect","particleScale","forEach","particle","index","targetRadius","waveOffset","pulseOffset","normalizedRadius","scale","lerpSpeed","particleOpacity","perspective","scale3D","x2D","y2D","color","beginPath","arc","fillStyle","fill","requestAnimationFrame","setupCanvas","dpr","window","devicePixelRatio","style","imageSmoothingEnabled","imageSmoothingQuality","cancelAnimationFrame","children","ref","background","borderRadius","filter","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/gagandeep.singh/Downloads/trp-main-feature-voice-first-ui/frontend2/src/components/AudioVisualization.tsx"],"sourcesContent":["import React, { useRef, useEffect, useState, useCallback } from 'react';\n\ninterface Particle {\n  x: number;\n  y: number;\n  z: number;\n  originalX: number;\n  originalY: number;\n  originalZ: number;\n  targetX: number;\n  targetY: number;\n  targetZ: number;\n  size: number;\n  opacity: number;\n  phase: number;\n  speed: number;\n}\n\ninterface AudioVisualizationProps {\n  isListening: boolean;\n  isSpeaking: boolean;\n  audioLevel: number;\n  className?: string;\n  size?: number;\n}\n\nconst AudioVisualization: React.FC<AudioVisualizationProps> = ({\n  isListening,\n  isSpeaking,\n  audioLevel = 0,\n  className = '',\n  size = 300\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const animationFrameRef = useRef<number | undefined>(undefined);\n  const particlesRef = useRef<Particle[]>([]);\n  const timeRef = useRef(0);\n\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [transitionFactor, setTransitionFactor] = useState(0);\n  const lastActiveRef = useRef(0);\n\n  // Initialize particles in a sphere formation\n  const initializeParticles = useCallback(() => {\n    const particles: Particle[] = [];\n    const particleCount = 250;\n    const radius = size * 0.35;\n\n    for (let i = 0; i < particleCount; i++) {\n      // Use fibonacci sphere for even distribution\n      const phi = Math.acos(-1 + (2 * i) / particleCount);\n      const theta = Math.sqrt(particleCount * Math.PI) * phi;\n\n      const x = radius * Math.cos(theta) * Math.sin(phi);\n      const y = radius * Math.sin(theta) * Math.sin(phi);\n      const z = radius * Math.cos(phi);\n\n      // Create varied particle sizes\n      let particleSize;\n      const sizeRandom = Math.random();\n      if (sizeRandom < 0.6) {\n        particleSize = Math.random() * 1.5 + 0.5;\n      } else {\n        particleSize = Math.random() * 2 + 2;\n      }\n\n      particles.push({\n        x,\n        y,\n        z,\n        originalX: x,\n        originalY: y,\n        originalZ: z,\n        targetX: x,\n        targetY: y,\n        targetZ: z,\n        size: particleSize,\n        opacity: Math.random() * 0.7 + 0.3,\n        phase: Math.random() * Math.PI * 2,\n        speed: Math.random() * 0.02 + 0.01\n      });\n    }\n\n    particlesRef.current = particles;\n    setIsInitialized(true);\n  }, [size]);\n\n  // Get color based on state with smooth interpolation\n  const getParticleColor = (state: 'idle' | 'listening' | 'speaking', opacity: number, transitionFactor: number) => {\n    const idleColor = { r: 59, g: 130, b: 246 }; // Blue\n    const listeningColor = { r: 59, g: 130, b: 246 }; // Blue\n    const speakingColor = { r: 20, g: 184, b: 166 }; // Teal\n    \n    let targetColor = idleColor;\n    if (state === 'listening') {\n      targetColor = listeningColor;\n    } else if (state === 'speaking') {\n      targetColor = speakingColor;\n    }\n    \n    // Smooth color interpolation\n    const r = Math.round(idleColor.r + (targetColor.r - idleColor.r) * transitionFactor);\n    const g = Math.round(idleColor.g + (targetColor.g - idleColor.g) * transitionFactor);\n    const b = Math.round(idleColor.b + (targetColor.b - idleColor.b) * transitionFactor);\n    \n    return `rgba(${r}, ${g}, ${b}, ${opacity})`;\n  };\n\n  // Animation loop\n  const animate = useCallback(() => {\n    const canvas = canvasRef.current;\n    if (!canvas || !isInitialized) return;\n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    timeRef.current += 0.016; // ~60fps\n\n    // Clear canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Use CSS size for calculations\n    const centerX = size / 2;\n    const centerY = size / 2;\n\n    // Smooth transition logic\n    const isCurrentlyActive = isListening || isSpeaking;\n    \n    if (isCurrentlyActive) {\n      lastActiveRef.current = timeRef.current;\n    }\n    \n    // Calculate smooth transition factor\n    const timeSinceActive = timeRef.current - lastActiveRef.current;\n    const fadeOutDuration = 1.5;\n    \n    let targetTransition = isCurrentlyActive ? 1 : Math.max(0, 1 - (timeSinceActive / fadeOutDuration));\n    \n    // Smooth interpolation towards target\n    const transitionSpeed = 0.05;\n    setTransitionFactor(prev => prev + (targetTransition - prev) * transitionSpeed);\n\n    // Determine base state for color mixing\n    let primaryState: 'idle' | 'listening' | 'speaking' = 'idle';\n    if (isSpeaking) primaryState = 'speaking';\n    else if (isListening || transitionFactor > 0.1) primaryState = 'listening';\n\n    // Animation parameters based on transition\n    const baseRadius = size * 0.35;\n    const radiusMultiplier = 1 + (audioLevel * 0.3 * transitionFactor);\n    const breathingEffect = Math.sin(timeRef.current * 2) * 0.05 + 1;\n    const particleScale = primaryState === 'speaking' ? 1 + (0.5 * transitionFactor) : 1;\n\n    particlesRef.current.forEach((particle, index) => {\n      // Update particle position based on state\n      let targetRadius = baseRadius * radiusMultiplier * breathingEffect;\n\n      if (primaryState === 'speaking') {\n        // Add wave effect for speaking\n        const waveOffset = Math.sin(timeRef.current * 3 + index * 0.1) * 20 * transitionFactor;\n        targetRadius += waveOffset;\n      } else if (primaryState === 'listening') {\n        // Add gentle pulsing for listening\n        const pulseOffset = Math.sin(timeRef.current * 4 + particle.phase) * 10 * transitionFactor;\n        targetRadius += pulseOffset;\n      }\n\n      // Calculate target position\n      const normalizedRadius = Math.sqrt(\n        particle.originalX ** 2 + particle.originalY ** 2 + particle.originalZ ** 2\n      );\n      const scale = targetRadius / normalizedRadius;\n\n      particle.targetX = particle.originalX * scale;\n      particle.targetY = particle.originalY * scale;\n      particle.targetZ = particle.originalZ * scale;\n\n      // Smooth interpolation to target position\n      const lerpSpeed = 0.08;\n      particle.x += (particle.targetX - particle.x) * lerpSpeed;\n      particle.y += (particle.targetY - particle.y) * lerpSpeed;\n      particle.z += (particle.targetZ - particle.z) * lerpSpeed;\n\n      // Update particle properties\n      particle.phase += particle.speed;\n\n      // Keep consistent opacity\n      let particleOpacity = particle.opacity;\n      if (primaryState === 'listening') {\n        particleOpacity *= (Math.sin(particle.phase) * 0.2 + 0.8);\n      } else if (primaryState === 'speaking') {\n        particleOpacity *= (Math.sin(particle.phase * 2) * 0.3 + 0.7);\n      }\n\n      // 3D to 2D projection\n      const perspective = 400;\n      const scale3D = perspective / (perspective + particle.z);\n      const x2D = centerX + particle.x * scale3D;\n      const y2D = centerY + particle.y * scale3D;\n\n      // Draw particle\n      const particleSize = particle.size * scale3D * particleScale;\n      const color = getParticleColor(primaryState, particleOpacity, transitionFactor);\n\n      ctx.beginPath();\n      ctx.arc(x2D, y2D, particleSize, 0, Math.PI * 2);\n      ctx.fillStyle = color;\n      ctx.fill();\n\n      // Add glow effect for active states\n      if (primaryState !== 'idle' && transitionFactor > 0.1) {\n        ctx.beginPath();\n        ctx.arc(x2D, y2D, particleSize * 2, 0, Math.PI * 2);\n        ctx.fillStyle = getParticleColor(primaryState, particleOpacity * 0.1, transitionFactor);\n        ctx.fill();\n      }\n    });\n\n    animationFrameRef.current = requestAnimationFrame(animate);\n  }, [isInitialized, isListening, isSpeaking, audioLevel, size]);\n\n  // Setup high-DPI canvas\n  const setupCanvas = useCallback(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    // Get device pixel ratio for crisp rendering\n    const dpr = window.devicePixelRatio || 1;\n    \n    // Set actual canvas size\n    canvas.width = size * dpr;\n    canvas.height = size * dpr;\n    \n    // Scale context for high DPI\n    ctx.scale(dpr, dpr);\n    \n    // Set CSS size\n    canvas.style.width = `${size}px`;\n    canvas.style.height = `${size}px`;\n    \n    // Enable anti-aliasing\n    ctx.imageSmoothingEnabled = true;\n    ctx.imageSmoothingQuality = 'high';\n  }, [size]);\n\n  // Initialize and start animation\n  useEffect(() => {\n    setupCanvas();\n    initializeParticles();\n  }, [setupCanvas, initializeParticles]);\n\n  useEffect(() => {\n    if (isInitialized) {\n      animate();\n    }\n\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [isInitialized, animate]);\n\n  return (\n    <div className={`flex items-center justify-center ${className}`}>\n      <canvas\n        ref={canvasRef}\n        style={{\n          background: 'transparent',\n          borderRadius: '50%',\n          filter: 'drop-shadow(0 10px 20px rgba(0, 0, 0, 0.3))',\n        }}\n      />\n    </div>\n  );\n};\n\nexport default AudioVisualization;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}