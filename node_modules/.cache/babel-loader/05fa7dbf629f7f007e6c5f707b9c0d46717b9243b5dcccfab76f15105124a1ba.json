{"ast":null,"code":"import { EventEmitter } from 'eventemitter3';\nimport { difference } from 'lodash';\nimport { isInterrupted, isModelTurn, isServerContentMessage, isSetupCompleteMessage, isToolCallCancellationMessage, isToolCallMessage, isTurnComplete } from '../types/multimodal-live-types';\nimport { blobToJSON, base64ToArrayBuffer } from './utils';\n\n/**\n * the events that this client will emit\n */\n\n/**\n * A event-emitting class that manages the connection to the websocket and emits\n * events to the rest of the application.\n */\nexport class MultimodalLiveClient extends EventEmitter {\n  getConfig() {\n    return {\n      ...this.config\n    };\n  }\n  constructor({\n    url,\n    apiKey\n  }) {\n    super();\n    this.ws = null;\n    this.config = null;\n    this.url = '';\n    url = url || `wss://generativelanguage.googleapis.com/ws/google.ai.generativelanguage.v1alpha.GenerativeService.BidiGenerateContent`;\n    url += `?key=${apiKey}`;\n    this.url = url;\n    this.send = this.send.bind(this);\n  }\n  log(type, message) {\n    const log = {\n      date: new Date(),\n      type,\n      message\n    };\n    this.emit('log', log);\n  }\n  connect(config) {\n    console.log('🌐 [MultimodalLiveClient] Starting connection process...');\n    console.log('📋 [MultimodalLiveClient] Config:', config);\n    console.log('🔗 [MultimodalLiveClient] URL:', this.url);\n    this.config = config;\n    console.log('🚀 [MultimodalLiveClient] Creating WebSocket...');\n    const ws = new WebSocket(this.url);\n    console.log('📡 [MultimodalLiveClient] WebSocket created, readyState:', ws.readyState);\n    ws.addEventListener('message', async evt => {\n      if (evt.data instanceof Blob) {\n        this.receive(evt.data);\n      } else {\n        console.log('📨 [MultimodalLiveClient] Non-blob message:', evt);\n      }\n    });\n    return new Promise((resolve, reject) => {\n      console.log('⏳ [MultimodalLiveClient] Setting up promise handlers...');\n      const onError = ev => {\n        console.error('❌ [MultimodalLiveClient] WebSocket error event:', ev);\n        console.error('🔍 [MultimodalLiveClient] WebSocket readyState on error:', ws.readyState);\n        this.disconnect(ws);\n        const message = `Could not connect to \"${this.url}\"`;\n        this.log(`server.${ev.type}`, message);\n        reject(new Error(message));\n      };\n      ws.addEventListener('error', onError);\n      ws.addEventListener('open', ev => {\n        console.log('✅ [MultimodalLiveClient] WebSocket opened successfully!');\n        console.log('🔍 [MultimodalLiveClient] WebSocket readyState on open:', ws.readyState);\n        if (!this.config) {\n          console.error('❌ [MultimodalLiveClient] No config available in open handler!');\n          reject('Invalid config sent to `connect(config)`');\n          return;\n        }\n        this.log(`client.${ev.type}`, `connected to socket`);\n        this.emit('open');\n        this.ws = ws;\n        console.log('📤 [MultimodalLiveClient] Sending setup message...');\n        const setupMessage = {\n          setup: this.config\n        };\n        this._sendDirect(setupMessage);\n        this.log('client.send', 'setup');\n        console.log('✅ [MultimodalLiveClient] Setup message sent successfully!');\n        ws.removeEventListener('error', onError);\n        ws.addEventListener('close', ev => {\n          console.log('🔌 [MultimodalLiveClient] WebSocket close event, code:', ev.code, 'reason:', ev);\n          this.disconnect(ws);\n          let reason = ev.reason || '';\n          if (reason.toLowerCase().includes('error')) {\n            const prelude = 'ERROR]';\n            const preludeIndex = reason.indexOf(prelude);\n            if (preludeIndex > 0) {\n              reason = reason.slice(preludeIndex + prelude.length + 1, Infinity);\n            }\n          }\n          this.log(`server.${ev.type}`, `disconnected ${reason ? `with reason: ${reason}` : ``}`);\n          this.emit('close', ev);\n        });\n        console.log('🎉 [MultimodalLiveClient] Connection process complete, resolving...');\n        resolve(true);\n      });\n    });\n  }\n  disconnect(ws) {\n    if ((!ws || this.ws === ws) && this.ws) {\n      this.ws.close();\n      this.ws = null;\n      this.log('client.close', `Disconnected`);\n      return true;\n    }\n    return false;\n  }\n  async receive(blob) {\n    const response = await blobToJSON(blob);\n    if (isToolCallMessage(response)) {\n      var _response$toolCall, _response$toolCall$fu, _response$toolCall2;\n      console.log('🔧 TOOL CALL RECEIVED by MultimodalLiveClient');\n      console.log('📞 Tool call response:', response);\n      console.log('📋 Function calls count:', ((_response$toolCall = response.toolCall) === null || _response$toolCall === void 0 ? void 0 : (_response$toolCall$fu = _response$toolCall.functionCalls) === null || _response$toolCall$fu === void 0 ? void 0 : _response$toolCall$fu.length) || 0);\n      if ((_response$toolCall2 = response.toolCall) !== null && _response$toolCall2 !== void 0 && _response$toolCall2.functionCalls) {\n        response.toolCall.functionCalls.forEach((fc, index) => {\n          console.log(`🎯 Function Call ${index + 1}:`);\n          console.log(`  📝 Name: ${fc.name}`);\n          console.log(`  🆔 ID: ${fc.id}`);\n          console.log(`  📋 Args:`, fc.args);\n        });\n      }\n      this.log('server.toolCall', response);\n      console.log('📡 Emitting toolcall event to listeners...');\n      this.emit('toolcall', response.toolCall);\n      console.log('✅ Tool call event emitted successfully');\n      return;\n    }\n    if (isToolCallCancellationMessage(response)) {\n      this.log('receive.toolCallCancellation', response);\n      this.emit('toolcallcancellation', response.toolCallCancellation);\n      return;\n    }\n    if (isSetupCompleteMessage(response)) {\n      this.log('server.send', 'setupComplete');\n      this.emit('setupcomplete');\n      return;\n    }\n    if (isServerContentMessage(response)) {\n      const {\n        serverContent\n      } = response;\n      if (isInterrupted(serverContent)) {\n        this.log('receive.serverContent', 'interrupted');\n        this.emit('interrupted');\n        return;\n      }\n      if (isTurnComplete(serverContent)) {\n        this.log('server.send', 'turnComplete');\n        this.emit('turncomplete');\n      }\n      if (isModelTurn(serverContent)) {\n        let parts = serverContent.modelTurn.parts;\n        const audioParts = parts.filter(p => p.inlineData && p.inlineData.mimeType.startsWith('audio/pcm'));\n        const base64s = audioParts.map(p => {\n          var _p$inlineData;\n          return (_p$inlineData = p.inlineData) === null || _p$inlineData === void 0 ? void 0 : _p$inlineData.data;\n        });\n        const otherParts = difference(parts, audioParts);\n        base64s.forEach(b64 => {\n          if (b64) {\n            const data = base64ToArrayBuffer(b64);\n            this.emit('audio', data);\n          }\n        });\n        if (!otherParts.length) {\n          return;\n        }\n        parts = otherParts;\n        const content = {\n          modelTurn: {\n            parts\n          }\n        };\n        this.emit('content', content);\n        this.log(`server.content`, response);\n      }\n    } else {\n      console.log('received unmatched message', response);\n    }\n  }\n  sendRealtimeInput(chunks) {\n    let hasAudio = false;\n    let hasVideo = false;\n    for (let i = 0; i < chunks.length; i++) {\n      const ch = chunks[i];\n      if (ch.mimeType.includes('audio')) {\n        hasAudio = true;\n      }\n      if (ch.mimeType.includes('image')) {\n        hasVideo = true;\n      }\n      if (hasAudio && hasVideo) {\n        break;\n      }\n    }\n    const message = hasAudio && hasVideo ? 'audio + video' : hasAudio ? 'audio' : hasVideo ? 'video' : 'unknown';\n    const data = {\n      realtimeInput: {\n        mediaChunks: chunks\n      }\n    };\n    this._sendDirect(data);\n    this.log(`client.realtimeInput`, message);\n  }\n  sendToolResponse(toolResponse) {\n    const message = {\n      toolResponse\n    };\n    this._sendDirect(message);\n    this.log(`client.toolResponse`, message);\n  }\n  send(parts, turnComplete = true) {\n    parts = Array.isArray(parts) ? parts : [parts];\n    const content = {\n      role: 'user',\n      parts\n    };\n    const clientContentRequest = {\n      clientContent: {\n        turns: [content],\n        turnComplete\n      }\n    };\n    this._sendDirect(clientContentRequest);\n    this.log(`client.send`, clientContentRequest);\n  }\n  updateConfig(newConfig) {\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n      throw new Error('WebSocket is not connected or not ready');\n    }\n    const updateEvent = {\n      type: \"session.update\",\n      session: {\n        ...newConfig\n      }\n    };\n    console.log(\"Sending session update event:\", updateEvent);\n    this.ws.send(JSON.stringify(updateEvent));\n    this.config = newConfig;\n    this.log('client.updateConfig', 'Session configuration updated');\n  }\n  _sendDirect(request) {\n    if (!this.ws) {\n      throw new Error('WebSocket is not connected');\n    }\n    const str = JSON.stringify(request);\n    this.ws.send(str);\n  }\n}","map":{"version":3,"names":["EventEmitter","difference","isInterrupted","isModelTurn","isServerContentMessage","isSetupCompleteMessage","isToolCallCancellationMessage","isToolCallMessage","isTurnComplete","blobToJSON","base64ToArrayBuffer","MultimodalLiveClient","getConfig","config","constructor","url","apiKey","ws","send","bind","log","type","message","date","Date","emit","connect","console","WebSocket","readyState","addEventListener","evt","data","Blob","receive","Promise","resolve","reject","onError","ev","error","disconnect","Error","setupMessage","setup","_sendDirect","removeEventListener","code","reason","toLowerCase","includes","prelude","preludeIndex","indexOf","slice","length","Infinity","close","blob","response","_response$toolCall","_response$toolCall$fu","_response$toolCall2","toolCall","functionCalls","forEach","fc","index","name","id","args","toolCallCancellation","serverContent","parts","modelTurn","audioParts","filter","p","inlineData","mimeType","startsWith","base64s","map","_p$inlineData","otherParts","b64","content","sendRealtimeInput","chunks","hasAudio","hasVideo","i","ch","realtimeInput","mediaChunks","sendToolResponse","toolResponse","turnComplete","Array","isArray","role","clientContentRequest","clientContent","turns","updateConfig","newConfig","OPEN","updateEvent","session","JSON","stringify","request","str"],"sources":["/Users/gagandeep.singh/Downloads/trp-main-feature-voice-first-ui/frontend2/src/lib/multimodal-live-client.ts"],"sourcesContent":["import { Content, GenerativeContentBlob, Part } from '@google/generative-ai';\nimport { EventEmitter } from 'eventemitter3';\nimport { difference } from 'lodash';\nimport {\n    ClientContentMessage,\n    isInterrupted,\n    isModelTurn,\n    isServerContentMessage,\n    isSetupCompleteMessage,\n    isToolCallCancellationMessage,\n    isToolCallMessage,\n    isTurnComplete,\n    LiveIncomingMessage,\n    ModelTurn,\n    RealtimeInputMessage,\n    ServerContent,\n    SetupMessage,\n    StreamingLog,\n    ToolCall,\n    ToolCallCancellation,\n    ToolResponseMessage,\n    type LiveConfig,\n} from '../types/multimodal-live-types';\nimport { blobToJSON, base64ToArrayBuffer } from './utils';\n\n/**\n * the events that this client will emit\n */\ninterface MultimodalLiveClientEventTypes {\n    open: () => void;\n    log: (log: StreamingLog) => void;\n    close: (event: CloseEvent) => void;\n    audio: (data: ArrayBuffer) => void;\n    content: (data: ServerContent) => void;\n    interrupted: () => void;\n    setupcomplete: () => void;\n    turncomplete: () => void;\n    toolcall: (toolCall: ToolCall) => void;\n    toolcallcancellation: (toolcallCancellation: ToolCallCancellation) => void;\n}\n\nexport type MultimodalLiveAPIClientConnection = {\n    url?: string;\n    apiKey: string;\n};\n\n/**\n * A event-emitting class that manages the connection to the websocket and emits\n * events to the rest of the application.\n */\nexport class MultimodalLiveClient extends EventEmitter<MultimodalLiveClientEventTypes> {\n    public ws: WebSocket | null = null;\n    protected config: LiveConfig | null = null;\n    public url: string = '';\n    \n    public getConfig() {\n        return { ...this.config };\n    }\n\n    constructor({ url, apiKey }: MultimodalLiveAPIClientConnection) {\n        super();\n        url =\n            url ||\n            `wss://generativelanguage.googleapis.com/ws/google.ai.generativelanguage.v1alpha.GenerativeService.BidiGenerateContent`;\n        url += `?key=${apiKey}`;\n        this.url = url;\n        this.send = this.send.bind(this);\n    }\n\n    log(type: string, message: StreamingLog['message']) {\n        const log: StreamingLog = {\n            date: new Date(),\n            type,\n            message,\n        };\n        this.emit('log', log);\n    }\n\n    connect(config: LiveConfig): Promise<boolean> {\n        console.log('🌐 [MultimodalLiveClient] Starting connection process...');\n        console.log('📋 [MultimodalLiveClient] Config:', config);\n        console.log('🔗 [MultimodalLiveClient] URL:', this.url);\n\n        this.config = config;\n\n        console.log('🚀 [MultimodalLiveClient] Creating WebSocket...');\n        const ws = new WebSocket(this.url);\n\n        console.log(\n            '📡 [MultimodalLiveClient] WebSocket created, readyState:',\n            ws.readyState\n        );\n\n        ws.addEventListener('message', async (evt: MessageEvent) => {\n            if (evt.data instanceof Blob) {\n                this.receive(evt.data);\n            } else {\n                console.log('📨 [MultimodalLiveClient] Non-blob message:', evt);\n            }\n        });\n\n        return new Promise((resolve, reject) => {\n            console.log(\n                '⏳ [MultimodalLiveClient] Setting up promise handlers...'\n            );\n\n            const onError = (ev: Event) => {\n                console.error(\n                    '❌ [MultimodalLiveClient] WebSocket error event:',\n                    ev\n                );\n                console.error(\n                    '🔍 [MultimodalLiveClient] WebSocket readyState on error:',\n                    ws.readyState\n                );\n                this.disconnect(ws);\n                const message = `Could not connect to \"${this.url}\"`;\n                this.log(`server.${ev.type}`, message);\n                reject(new Error(message));\n            };\n\n            ws.addEventListener('error', onError);\n\n            ws.addEventListener('open', (ev: Event) => {\n                console.log(\n                    '✅ [MultimodalLiveClient] WebSocket opened successfully!'\n                );\n                console.log(\n                    '🔍 [MultimodalLiveClient] WebSocket readyState on open:',\n                    ws.readyState\n                );\n\n                if (!this.config) {\n                    console.error(\n                        '❌ [MultimodalLiveClient] No config available in open handler!'\n                    );\n                    reject('Invalid config sent to `connect(config)`');\n                    return;\n                }\n\n                this.log(`client.${ev.type}`, `connected to socket`);\n                this.emit('open');\n\n                this.ws = ws;\n\n                console.log(\n                    '📤 [MultimodalLiveClient] Sending setup message...'\n                );\n                const setupMessage: SetupMessage = {\n                    setup: this.config,\n                };\n                this._sendDirect(setupMessage);\n                this.log('client.send', 'setup');\n                console.log(\n                    '✅ [MultimodalLiveClient] Setup message sent successfully!'\n                );\n\n                ws.removeEventListener('error', onError);\n                ws.addEventListener('close', (ev: CloseEvent) => {\n                    console.log(\n                        '🔌 [MultimodalLiveClient] WebSocket close event, code:',\n                        ev.code,\n                        'reason:',\n                        ev\n                    );\n                    this.disconnect(ws);\n                    let reason = ev.reason || '';\n                    if (reason.toLowerCase().includes('error')) {\n                        const prelude = 'ERROR]';\n                        const preludeIndex = reason.indexOf(prelude);\n                        if (preludeIndex > 0) {\n                            reason = reason.slice(\n                                preludeIndex + prelude.length + 1,\n                                Infinity\n                            );\n                        }\n                    }\n                    this.log(\n                        `server.${ev.type}`,\n                        `disconnected ${reason ? `with reason: ${reason}` : ``}`\n                    );\n                    this.emit('close', ev);\n                });\n\n                console.log(\n                    '🎉 [MultimodalLiveClient] Connection process complete, resolving...'\n                );\n                resolve(true);\n            });\n        });\n    }\n\n    disconnect(ws?: WebSocket) {\n        if ((!ws || this.ws === ws) && this.ws) {\n            this.ws.close();\n            this.ws = null;\n            this.log('client.close', `Disconnected`);\n            return true;\n        }\n        return false;\n    }\n\n    protected async receive(blob: Blob) {\n        const response: LiveIncomingMessage = (await blobToJSON(\n            blob\n        )) as LiveIncomingMessage;\n        \n        if (isToolCallMessage(response)) {\n            console.log('🔧 TOOL CALL RECEIVED by MultimodalLiveClient');\n            console.log('📞 Tool call response:', response);\n            console.log('📋 Function calls count:', response.toolCall?.functionCalls?.length || 0);\n            \n            if (response.toolCall?.functionCalls) {\n                response.toolCall.functionCalls.forEach((fc, index) => {\n                    console.log(`🎯 Function Call ${index + 1}:`);\n                    console.log(`  📝 Name: ${fc.name}`);\n                    console.log(`  🆔 ID: ${fc.id}`);\n                    console.log(`  📋 Args:`, fc.args);\n                });\n            }\n            \n            this.log('server.toolCall', response);\n            console.log('📡 Emitting toolcall event to listeners...');\n            this.emit('toolcall', response.toolCall);\n            console.log('✅ Tool call event emitted successfully');\n            return;\n        }\n        \n        if (isToolCallCancellationMessage(response)) {\n            this.log('receive.toolCallCancellation', response);\n            this.emit('toolcallcancellation', response.toolCallCancellation);\n            return;\n        }\n\n        if (isSetupCompleteMessage(response)) {\n            this.log('server.send', 'setupComplete');\n            this.emit('setupcomplete');\n            return;\n        }\n\n        if (isServerContentMessage(response)) {\n            const { serverContent } = response;\n            if (isInterrupted(serverContent)) {\n                this.log('receive.serverContent', 'interrupted');\n                this.emit('interrupted');\n                return;\n            }\n            if (isTurnComplete(serverContent)) {\n                this.log('server.send', 'turnComplete');\n                this.emit('turncomplete');\n            }\n\n            if (isModelTurn(serverContent)) {\n                let parts: Part[] = serverContent.modelTurn.parts;\n\n                const audioParts = parts.filter(\n                    (p) =>\n                        p.inlineData &&\n                        p.inlineData.mimeType.startsWith('audio/pcm')\n                );\n                const base64s = audioParts.map((p) => p.inlineData?.data);\n\n                const otherParts = difference(parts, audioParts);\n\n                base64s.forEach((b64) => {\n                    if (b64) {\n                        const data = base64ToArrayBuffer(b64);\n                        this.emit('audio', data);\n                    }\n                });\n                \n                if (!otherParts.length) {\n                    return;\n                }\n\n                parts = otherParts;\n                const content: ModelTurn = { modelTurn: { parts } };\n                this.emit('content', content);\n                this.log(`server.content`, response);\n            }\n        } else {\n            console.log('received unmatched message', response);\n        }\n    }\n\n    sendRealtimeInput(chunks: GenerativeContentBlob[]) {\n        let hasAudio = false;\n        let hasVideo = false;\n        for (let i = 0; i < chunks.length; i++) {\n            const ch = chunks[i];\n            if (ch.mimeType.includes('audio')) {\n                hasAudio = true;\n            }\n            if (ch.mimeType.includes('image')) {\n                hasVideo = true;\n            }\n            if (hasAudio && hasVideo) {\n                break;\n            }\n        }\n        const message =\n            hasAudio && hasVideo\n                ? 'audio + video'\n                : hasAudio\n                ? 'audio'\n                : hasVideo\n                ? 'video'\n                : 'unknown';\n\n        const data: RealtimeInputMessage = {\n            realtimeInput: {\n                mediaChunks: chunks,\n            },\n        };\n        this._sendDirect(data);\n        this.log(`client.realtimeInput`, message);\n    }\n\n    sendToolResponse(toolResponse: ToolResponseMessage['toolResponse']) {\n        const message: ToolResponseMessage = {\n            toolResponse,\n        };\n\n        this._sendDirect(message);\n        this.log(`client.toolResponse`, message);\n    }\n\n    send(parts: Part | Part[], turnComplete: boolean = true) {\n        parts = Array.isArray(parts) ? parts : [parts];\n        const content: Content = {\n            role: 'user',\n            parts,\n        };\n\n        const clientContentRequest: ClientContentMessage = {\n            clientContent: {\n                turns: [content],\n                turnComplete,\n            },\n        };\n\n        this._sendDirect(clientContentRequest);\n        this.log(`client.send`, clientContentRequest);\n    }\n\n    updateConfig(newConfig: LiveConfig) {\n        if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n            throw new Error('WebSocket is not connected or not ready');\n        }\n        \n        const updateEvent = {\n            type: \"session.update\",\n            session: {\n                ...newConfig,\n            },\n        };\n        \n        console.log(\"Sending session update event:\", updateEvent);\n        this.ws.send(JSON.stringify(updateEvent));\n        this.config = newConfig;\n        this.log('client.updateConfig', 'Session configuration updated');\n    }\n\n    _sendDirect(request: object) {\n        if (!this.ws) {\n            throw new Error('WebSocket is not connected');\n        }\n        const str = JSON.stringify(request);\n        this.ws.send(str);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}