{"ast":null,"code":"export class AudioStreamer {\n  constructor(audioContext) {\n    this.audioContext = void 0;\n    this.gainNode = void 0;\n    this.workletNode = null;\n    this.isPlaying = false;\n    this.audioContext = audioContext;\n    this.gainNode = audioContext.createGain();\n    this.gainNode.connect(audioContext.destination);\n  }\n  async addWorklet(name, workletClass, onMessage) {\n    try {\n      // Create a simple volume meter worklet inline\n      const workletCode = `\n                class VolMeterProcessor extends AudioWorkletProcessor {\n                    constructor() {\n                        super();\n                        this.volume = 0;\n                        this.updateIntervalInFrames = 512;\n                        this.nextUpdateFrame = this.updateIntervalInFrames;\n                    }\n\n                    process(inputs, outputs, parameters) {\n                        const input = inputs[0];\n                        const output = outputs[0];\n\n                        if (input.length > 0) {\n                            const inputChannel = input[0];\n                            const outputChannel = output[0];\n\n                            // Copy input to output\n                            for (let i = 0; i < inputChannel.length; i++) {\n                                outputChannel[i] = inputChannel[i];\n                            }\n\n                            // Calculate volume\n                            let sum = 0;\n                            for (let i = 0; i < inputChannel.length; i++) {\n                                sum += inputChannel[i] * inputChannel[i];\n                            }\n                            const rms = Math.sqrt(sum / inputChannel.length);\n                            this.volume = Math.max(this.volume * 0.95, rms);\n\n                            // Send volume updates\n                            this.nextUpdateFrame -= inputChannel.length;\n                            if (this.nextUpdateFrame < 0) {\n                                this.nextUpdateFrame += this.updateIntervalInFrames;\n                                this.port.postMessage({ volume: this.volume });\n                            }\n                        }\n\n                        return true;\n                    }\n                }\n\n                registerProcessor('vumeter-out', VolMeterProcessor);\n            `;\n      const blob = new Blob([workletCode], {\n        type: 'application/javascript'\n      });\n      const workletUrl = URL.createObjectURL(blob);\n      await this.audioContext.audioWorklet.addModule(workletUrl);\n      this.workletNode = new AudioWorkletNode(this.audioContext, 'vumeter-out');\n      this.workletNode.port.onmessage = onMessage;\n      this.workletNode.connect(this.gainNode);\n      URL.revokeObjectURL(workletUrl);\n    } catch (error) {\n      console.warn('Failed to add audio worklet:', error);\n    }\n  }\n  addPCM16(data) {\n    if (!this.audioContext || this.audioContext.state !== 'running') {\n      return;\n    }\n    try {\n      // Convert PCM16 to Float32Array\n      const samples = new Float32Array(data.length / 2);\n      const dataView = new DataView(data.buffer);\n      for (let i = 0; i < samples.length; i++) {\n        const sample = dataView.getInt16(i * 2, true); // little endian\n        samples[i] = sample / 32768.0; // Convert to -1.0 to 1.0 range\n      }\n\n      // Create audio buffer\n      const audioBuffer = this.audioContext.createBuffer(1, samples.length, 16000);\n      audioBuffer.copyToChannel(samples, 0);\n\n      // Create and play buffer source\n      const source = this.audioContext.createBufferSource();\n      source.buffer = audioBuffer;\n      if (this.workletNode) {\n        source.connect(this.workletNode);\n      } else {\n        source.connect(this.gainNode);\n      }\n      source.start();\n      this.isPlaying = true;\n      source.onended = () => {\n        this.isPlaying = false;\n      };\n    } catch (error) {\n      console.error('Error playing audio:', error);\n    }\n  }\n  stop() {\n    this.isPlaying = false;\n  }\n  setVolume(volume) {\n    this.gainNode.gain.value = Math.max(0, Math.min(1, volume));\n  }\n}","map":{"version":3,"names":["AudioStreamer","constructor","audioContext","gainNode","workletNode","isPlaying","createGain","connect","destination","addWorklet","name","workletClass","onMessage","workletCode","blob","Blob","type","workletUrl","URL","createObjectURL","audioWorklet","addModule","AudioWorkletNode","port","onmessage","revokeObjectURL","error","console","warn","addPCM16","data","state","samples","Float32Array","length","dataView","DataView","buffer","i","sample","getInt16","audioBuffer","createBuffer","copyToChannel","source","createBufferSource","start","onended","stop","setVolume","volume","gain","value","Math","max","min"],"sources":["/Users/gagandeep.singh/Downloads/trp-main-feature-voice-first-ui/frontend2/src/lib/audio-streamer.ts"],"sourcesContent":["export class AudioStreamer {\n    private audioContext: AudioContext;\n    private gainNode: GainNode;\n    private workletNode: AudioWorkletNode | null = null;\n    private isPlaying: boolean = false;\n\n    constructor(audioContext: AudioContext) {\n        this.audioContext = audioContext;\n        this.gainNode = audioContext.createGain();\n        this.gainNode.connect(audioContext.destination);\n    }\n\n    async addWorklet<T>(\n        name: string,\n        workletClass: any,\n        onMessage: (event: MessageEvent<T>) => void\n    ): Promise<void> {\n        try {\n            // Create a simple volume meter worklet inline\n            const workletCode = `\n                class VolMeterProcessor extends AudioWorkletProcessor {\n                    constructor() {\n                        super();\n                        this.volume = 0;\n                        this.updateIntervalInFrames = 512;\n                        this.nextUpdateFrame = this.updateIntervalInFrames;\n                    }\n\n                    process(inputs, outputs, parameters) {\n                        const input = inputs[0];\n                        const output = outputs[0];\n\n                        if (input.length > 0) {\n                            const inputChannel = input[0];\n                            const outputChannel = output[0];\n\n                            // Copy input to output\n                            for (let i = 0; i < inputChannel.length; i++) {\n                                outputChannel[i] = inputChannel[i];\n                            }\n\n                            // Calculate volume\n                            let sum = 0;\n                            for (let i = 0; i < inputChannel.length; i++) {\n                                sum += inputChannel[i] * inputChannel[i];\n                            }\n                            const rms = Math.sqrt(sum / inputChannel.length);\n                            this.volume = Math.max(this.volume * 0.95, rms);\n\n                            // Send volume updates\n                            this.nextUpdateFrame -= inputChannel.length;\n                            if (this.nextUpdateFrame < 0) {\n                                this.nextUpdateFrame += this.updateIntervalInFrames;\n                                this.port.postMessage({ volume: this.volume });\n                            }\n                        }\n\n                        return true;\n                    }\n                }\n\n                registerProcessor('vumeter-out', VolMeterProcessor);\n            `;\n\n            const blob = new Blob([workletCode], { type: 'application/javascript' });\n            const workletUrl = URL.createObjectURL(blob);\n\n            await this.audioContext.audioWorklet.addModule(workletUrl);\n            \n            this.workletNode = new AudioWorkletNode(this.audioContext, 'vumeter-out');\n            this.workletNode.port.onmessage = onMessage;\n            this.workletNode.connect(this.gainNode);\n\n            URL.revokeObjectURL(workletUrl);\n        } catch (error) {\n            console.warn('Failed to add audio worklet:', error);\n        }\n    }\n\n    addPCM16(data: Uint8Array): void {\n        if (!this.audioContext || this.audioContext.state !== 'running') {\n            return;\n        }\n\n        try {\n            // Convert PCM16 to Float32Array\n            const samples = new Float32Array(data.length / 2);\n            const dataView = new DataView(data.buffer);\n            \n            for (let i = 0; i < samples.length; i++) {\n                const sample = dataView.getInt16(i * 2, true); // little endian\n                samples[i] = sample / 32768.0; // Convert to -1.0 to 1.0 range\n            }\n\n            // Create audio buffer\n            const audioBuffer = this.audioContext.createBuffer(1, samples.length, 16000);\n            audioBuffer.copyToChannel(samples, 0);\n\n            // Create and play buffer source\n            const source = this.audioContext.createBufferSource();\n            source.buffer = audioBuffer;\n            \n            if (this.workletNode) {\n                source.connect(this.workletNode);\n            } else {\n                source.connect(this.gainNode);\n            }\n            \n            source.start();\n            this.isPlaying = true;\n\n            source.onended = () => {\n                this.isPlaying = false;\n            };\n        } catch (error) {\n            console.error('Error playing audio:', error);\n        }\n    }\n\n    stop(): void {\n        this.isPlaying = false;\n    }\n\n    setVolume(volume: number): void {\n        this.gainNode.gain.value = Math.max(0, Math.min(1, volume));\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}