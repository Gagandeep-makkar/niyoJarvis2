{"ast":null,"code":"import { EventEmitter } from 'eventemitter3';\nexport class AudioRecorder extends EventEmitter {\n  constructor() {\n    super();\n    this.mediaStream = null;\n    this.mediaRecorder = null;\n    this.audioContext = null;\n    this.analyser = null;\n    this.isRecording = false;\n    this.volumeCheckInterval = null;\n  }\n  async start() {\n    try {\n      // Request microphone access\n      this.mediaStream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          sampleRate: 16000,\n          channelCount: 1,\n          echoCancellation: true,\n          noiseSuppression: true\n        }\n      });\n\n      // Set up audio context for volume monitoring\n      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();\n      const source = this.audioContext.createMediaStreamSource(this.mediaStream);\n      this.analyser = this.audioContext.createAnalyser();\n      this.analyser.fftSize = 256;\n      source.connect(this.analyser);\n\n      // Set up MediaRecorder for audio data\n      this.mediaRecorder = new MediaRecorder(this.mediaStream, {\n        mimeType: 'audio/webm;codecs=opus'\n      });\n      this.mediaRecorder.ondataavailable = event => {\n        if (event.data.size > 0) {\n          this.processAudioData(event.data);\n        }\n      };\n\n      // Start recording\n      this.mediaRecorder.start(100); // Get data every 100ms\n      this.isRecording = true;\n\n      // Start volume monitoring\n      this.startVolumeMonitoring();\n      console.log('Audio recording started');\n    } catch (error) {\n      console.error('Failed to start audio recording:', error);\n      throw error;\n    }\n  }\n  stop() {\n    if (this.mediaRecorder && this.isRecording) {\n      this.mediaRecorder.stop();\n      this.isRecording = false;\n    }\n    if (this.mediaStream) {\n      this.mediaStream.getTracks().forEach(track => track.stop());\n      this.mediaStream = null;\n    }\n    if (this.audioContext) {\n      this.audioContext.close();\n      this.audioContext = null;\n    }\n    if (this.volumeCheckInterval) {\n      clearInterval(this.volumeCheckInterval);\n      this.volumeCheckInterval = null;\n    }\n    console.log('Audio recording stopped');\n  }\n  async processAudioData(blob) {\n    try {\n      // Convert blob to ArrayBuffer\n      const arrayBuffer = await blob.arrayBuffer();\n\n      // For simplicity, we'll convert to base64\n      // In a real implementation, you might want to convert to PCM16\n      const base64 = this.arrayBufferToBase64(arrayBuffer);\n      this.emit('data', base64);\n    } catch (error) {\n      console.error('Error processing audio data:', error);\n    }\n  }\n  arrayBufferToBase64(buffer) {\n    const bytes = new Uint8Array(buffer);\n    let binary = '';\n    for (let i = 0; i < bytes.byteLength; i++) {\n      binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary);\n  }\n  startVolumeMonitoring() {\n    if (!this.analyser) return;\n    const bufferLength = this.analyser.frequencyBinCount;\n    const dataArray = new Uint8Array(bufferLength);\n    this.volumeCheckInterval = window.setInterval(() => {\n      if (!this.analyser) return;\n      this.analyser.getByteFrequencyData(dataArray);\n\n      // Calculate average volume\n      let sum = 0;\n      for (let i = 0; i < bufferLength; i++) {\n        sum += dataArray[i];\n      }\n      const average = sum / bufferLength;\n      const volume = average / 255; // Normalize to 0-1\n\n      this.emit('volume', volume);\n    }, 50); // Update volume every 50ms\n  }\n}","map":{"version":3,"names":["EventEmitter","AudioRecorder","constructor","mediaStream","mediaRecorder","audioContext","analyser","isRecording","volumeCheckInterval","start","navigator","mediaDevices","getUserMedia","audio","sampleRate","channelCount","echoCancellation","noiseSuppression","window","AudioContext","webkitAudioContext","source","createMediaStreamSource","createAnalyser","fftSize","connect","MediaRecorder","mimeType","ondataavailable","event","data","size","processAudioData","startVolumeMonitoring","console","log","error","stop","getTracks","forEach","track","close","clearInterval","blob","arrayBuffer","base64","arrayBufferToBase64","emit","buffer","bytes","Uint8Array","binary","i","byteLength","String","fromCharCode","btoa","bufferLength","frequencyBinCount","dataArray","setInterval","getByteFrequencyData","sum","average","volume"],"sources":["/Users/gagandeep.singh/Downloads/trp-main-feature-voice-first-ui/frontend2/src/lib/audio-recorder.ts"],"sourcesContent":["import { EventEmitter } from 'eventemitter3';\n\nexport class AudioRecorder extends EventEmitter {\n    private mediaStream: MediaStream | null = null;\n    private mediaRecorder: MediaRecorder | null = null;\n    private audioContext: AudioContext | null = null;\n    private analyser: AnalyserNode | null = null;\n    private isRecording: boolean = false;\n    private volumeCheckInterval: number | null = null;\n\n    constructor() {\n        super();\n    }\n\n    async start(): Promise<void> {\n        try {\n            // Request microphone access\n            this.mediaStream = await navigator.mediaDevices.getUserMedia({\n                audio: {\n                    sampleRate: 16000,\n                    channelCount: 1,\n                    echoCancellation: true,\n                    noiseSuppression: true,\n                }\n            });\n\n            // Set up audio context for volume monitoring\n            this.audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\n            const source = this.audioContext.createMediaStreamSource(this.mediaStream);\n            this.analyser = this.audioContext.createAnalyser();\n            this.analyser.fftSize = 256;\n            source.connect(this.analyser);\n\n            // Set up MediaRecorder for audio data\n            this.mediaRecorder = new MediaRecorder(this.mediaStream, {\n                mimeType: 'audio/webm;codecs=opus'\n            });\n\n            this.mediaRecorder.ondataavailable = (event) => {\n                if (event.data.size > 0) {\n                    this.processAudioData(event.data);\n                }\n            };\n\n            // Start recording\n            this.mediaRecorder.start(100); // Get data every 100ms\n            this.isRecording = true;\n\n            // Start volume monitoring\n            this.startVolumeMonitoring();\n\n            console.log('Audio recording started');\n        } catch (error) {\n            console.error('Failed to start audio recording:', error);\n            throw error;\n        }\n    }\n\n    stop(): void {\n        if (this.mediaRecorder && this.isRecording) {\n            this.mediaRecorder.stop();\n            this.isRecording = false;\n        }\n\n        if (this.mediaStream) {\n            this.mediaStream.getTracks().forEach(track => track.stop());\n            this.mediaStream = null;\n        }\n\n        if (this.audioContext) {\n            this.audioContext.close();\n            this.audioContext = null;\n        }\n\n        if (this.volumeCheckInterval) {\n            clearInterval(this.volumeCheckInterval);\n            this.volumeCheckInterval = null;\n        }\n\n        console.log('Audio recording stopped');\n    }\n\n    private async processAudioData(blob: Blob): Promise<void> {\n        try {\n            // Convert blob to ArrayBuffer\n            const arrayBuffer = await blob.arrayBuffer();\n            \n            // For simplicity, we'll convert to base64\n            // In a real implementation, you might want to convert to PCM16\n            const base64 = this.arrayBufferToBase64(arrayBuffer);\n            \n            this.emit('data', base64);\n        } catch (error) {\n            console.error('Error processing audio data:', error);\n        }\n    }\n\n    private arrayBufferToBase64(buffer: ArrayBuffer): string {\n        const bytes = new Uint8Array(buffer);\n        let binary = '';\n        for (let i = 0; i < bytes.byteLength; i++) {\n            binary += String.fromCharCode(bytes[i]);\n        }\n        return btoa(binary);\n    }\n\n    private startVolumeMonitoring(): void {\n        if (!this.analyser) return;\n\n        const bufferLength = this.analyser.frequencyBinCount;\n        const dataArray = new Uint8Array(bufferLength);\n\n        this.volumeCheckInterval = window.setInterval(() => {\n            if (!this.analyser) return;\n\n            this.analyser.getByteFrequencyData(dataArray);\n            \n            // Calculate average volume\n            let sum = 0;\n            for (let i = 0; i < bufferLength; i++) {\n                sum += dataArray[i];\n            }\n            const average = sum / bufferLength;\n            const volume = average / 255; // Normalize to 0-1\n\n            this.emit('volume', volume);\n        }, 50); // Update volume every 50ms\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}