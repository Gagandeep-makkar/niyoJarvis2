{"ast":null,"code":"import { createWorketFromSrc, registeredWorklets } from './audioworklet-registry.ts';\nexport class AudioStreamer {\n  constructor(context) {\n    this.context = context;\n    this.audioQueue = [];\n    this.isPlaying = false;\n    this.sampleRate = 24000;\n    this.bufferSize = 7680;\n    this.processingBuffer = new Float32Array(0);\n    this.scheduledTime = 0;\n    this.gainNode = void 0;\n    this.source = void 0;\n    this.isStreamComplete = false;\n    this.checkInterval = null;\n    this.initialBufferTime = 0.1;\n    // 100ms initial buffer\n    this.endOfQueueAudioSource = null;\n    this.onComplete = () => {};\n    this.gainNode = this.context.createGain();\n    this.source = this.context.createBufferSource();\n    this.gainNode.connect(this.context.destination);\n    this.addPCM16 = this.addPCM16.bind(this);\n  }\n  async addWorklet(workletName, workletSrc, handler) {\n    let workletsRecord = registeredWorklets.get(this.context);\n    if (workletsRecord && workletsRecord[workletName]) {\n      // the worklet already exists on this context\n      // add the new handler to it\n      workletsRecord[workletName].handlers.push(handler);\n      return Promise.resolve(this);\n    }\n    if (!workletsRecord) {\n      registeredWorklets.set(this.context, {});\n      workletsRecord = registeredWorklets.get(this.context);\n    }\n\n    // create new record to fill in as becomes available\n    workletsRecord[workletName] = {\n      handlers: [handler]\n    };\n    const src = createWorketFromSrc(workletName, workletSrc);\n    await this.context.audioWorklet.addModule(src);\n    const worklet = new AudioWorkletNode(this.context, workletName);\n\n    //add the node into the map\n    workletsRecord[workletName].node = worklet;\n    return this;\n  }\n  addPCM16(chunk) {\n    const float32Array = new Float32Array(chunk.length / 2);\n    const dataView = new DataView(chunk.buffer);\n    for (let i = 0; i < chunk.length / 2; i++) {\n      try {\n        const int16 = dataView.getInt16(i * 2, true);\n        float32Array[i] = int16 / 32768;\n      } catch (e) {\n        console.error(e);\n      }\n    }\n    const newBuffer = new Float32Array(this.processingBuffer.length + float32Array.length);\n    newBuffer.set(this.processingBuffer);\n    newBuffer.set(float32Array, this.processingBuffer.length);\n    this.processingBuffer = newBuffer;\n    while (this.processingBuffer.length >= this.bufferSize) {\n      const buffer = this.processingBuffer.slice(0, this.bufferSize);\n      this.audioQueue.push(buffer);\n      this.processingBuffer = this.processingBuffer.slice(this.bufferSize);\n    }\n    if (!this.isPlaying) {\n      this.isPlaying = true;\n      // Initialize scheduledTime only when we start playing\n      this.scheduledTime = this.context.currentTime + this.initialBufferTime;\n      this.scheduleNextBuffer();\n    }\n  }\n  createAudioBuffer(audioData) {\n    const audioBuffer = this.context.createBuffer(1, audioData.length, this.sampleRate);\n    audioBuffer.getChannelData(0).set(audioData);\n    return audioBuffer;\n  }\n  scheduleNextBuffer() {\n    const SCHEDULE_AHEAD_TIME = 0.2;\n    while (this.audioQueue.length > 0 && this.scheduledTime < this.context.currentTime + SCHEDULE_AHEAD_TIME) {\n      const audioData = this.audioQueue.shift();\n      const audioBuffer = this.createAudioBuffer(audioData);\n      const source = this.context.createBufferSource();\n      if (this.audioQueue.length === 0) {\n        if (this.endOfQueueAudioSource) {\n          this.endOfQueueAudioSource.onended = null;\n        }\n        this.endOfQueueAudioSource = source;\n        source.onended = () => {\n          if (!this.audioQueue.length && this.endOfQueueAudioSource === source) {\n            this.endOfQueueAudioSource = null;\n            this.onComplete();\n          }\n        };\n      }\n      source.buffer = audioBuffer;\n      source.connect(this.gainNode);\n      const worklets = registeredWorklets.get(this.context);\n      if (worklets) {\n        Object.entries(worklets).forEach(([workletName, graph]) => {\n          const {\n            node,\n            handlers\n          } = graph;\n          if (node) {\n            source.connect(node);\n            node.port.onmessage = function (ev) {\n              handlers.forEach(handler => {\n                handler.call(node.port, ev);\n              });\n            };\n            node.connect(this.context.destination);\n          }\n        });\n      }\n\n      // Ensure we never schedule in the past\n      const startTime = Math.max(this.scheduledTime, this.context.currentTime);\n      source.start(startTime);\n      this.scheduledTime = startTime + audioBuffer.duration;\n    }\n    if (this.audioQueue.length === 0 && this.processingBuffer.length === 0) {\n      if (this.isStreamComplete) {\n        this.isPlaying = false;\n        if (this.checkInterval) {\n          clearInterval(this.checkInterval);\n          this.checkInterval = null;\n        }\n      } else {\n        if (!this.checkInterval) {\n          this.checkInterval = window.setInterval(() => {\n            if (this.audioQueue.length > 0 || this.processingBuffer.length >= this.bufferSize) {\n              this.scheduleNextBuffer();\n            }\n          }, 100);\n        }\n      }\n    } else {\n      const nextCheckTime = (this.scheduledTime - this.context.currentTime) * 1000;\n      setTimeout(() => this.scheduleNextBuffer(), Math.max(0, nextCheckTime - 50));\n    }\n  }\n  stop() {\n    this.isPlaying = false;\n    this.isStreamComplete = true;\n    this.audioQueue = [];\n    this.processingBuffer = new Float32Array(0);\n    this.scheduledTime = this.context.currentTime;\n    if (this.checkInterval) {\n      clearInterval(this.checkInterval);\n      this.checkInterval = null;\n    }\n    this.gainNode.gain.linearRampToValueAtTime(0, this.context.currentTime + 0.1);\n    setTimeout(() => {\n      this.gainNode.disconnect();\n      this.gainNode = this.context.createGain();\n      this.gainNode.connect(this.context.destination);\n    }, 200);\n  }\n  async resume() {\n    if (this.context.state === 'suspended') {\n      await this.context.resume();\n    }\n    this.isStreamComplete = false;\n    this.scheduledTime = this.context.currentTime + this.initialBufferTime;\n    this.gainNode.gain.setValueAtTime(1, this.context.currentTime);\n  }\n  complete() {\n    this.isStreamComplete = true;\n    if (this.processingBuffer.length > 0) {\n      this.audioQueue.push(this.processingBuffer);\n      this.processingBuffer = new Float32Array(0);\n      if (this.isPlaying) {\n        this.scheduleNextBuffer();\n      }\n    } else {\n      this.onComplete();\n    }\n  }\n}","map":{"version":3,"names":["createWorketFromSrc","registeredWorklets","AudioStreamer","constructor","context","audioQueue","isPlaying","sampleRate","bufferSize","processingBuffer","Float32Array","scheduledTime","gainNode","source","isStreamComplete","checkInterval","initialBufferTime","endOfQueueAudioSource","onComplete","createGain","createBufferSource","connect","destination","addPCM16","bind","addWorklet","workletName","workletSrc","handler","workletsRecord","get","handlers","push","Promise","resolve","set","src","audioWorklet","addModule","worklet","AudioWorkletNode","node","chunk","float32Array","length","dataView","DataView","buffer","i","int16","getInt16","e","console","error","newBuffer","slice","currentTime","scheduleNextBuffer","createAudioBuffer","audioData","audioBuffer","createBuffer","getChannelData","SCHEDULE_AHEAD_TIME","shift","onended","worklets","Object","entries","forEach","graph","port","onmessage","ev","call","startTime","Math","max","start","duration","clearInterval","window","setInterval","nextCheckTime","setTimeout","stop","gain","linearRampToValueAtTime","disconnect","resume","state","setValueAtTime","complete"],"sources":["/Users/gagandeep.singh/Downloads/trp-main-feature-voice-first-ui/frontend2/src/lib/AudioStreamer.ts"],"sourcesContent":["import {\n    createWorketFromSrc,\n    registeredWorklets,\n} from './audioworklet-registry.ts';\n\nexport class AudioStreamer {\n    public audioQueue: Float32Array[] = [];\n    private isPlaying: boolean = false;\n    private sampleRate: number = 24000;\n    private bufferSize: number = 7680;\n    private processingBuffer: Float32Array = new Float32Array(0);\n    private scheduledTime: number = 0;\n    public gainNode: GainNode;\n    public source: AudioBufferSourceNode;\n    private isStreamComplete: boolean = false;\n    private checkInterval: number | null = null;\n    private initialBufferTime: number = 0.1; // 100ms initial buffer\n    private endOfQueueAudioSource: AudioBufferSourceNode | null = null;\n\n    public onComplete = () => {};\n\n    constructor(public context: AudioContext) {\n        this.gainNode = this.context.createGain();\n        this.source = this.context.createBufferSource();\n        this.gainNode.connect(this.context.destination);\n        this.addPCM16 = this.addPCM16.bind(this);\n    }\n\n    async addWorklet<T extends (d: any) => void>(\n        workletName: string,\n        workletSrc: string,\n        handler: T\n    ): Promise<this> {\n        let workletsRecord = registeredWorklets.get(this.context);\n        if (workletsRecord && workletsRecord[workletName]) {\n            // the worklet already exists on this context\n            // add the new handler to it\n            workletsRecord[workletName].handlers.push(handler);\n            return Promise.resolve(this);\n        }\n\n        if (!workletsRecord) {\n            registeredWorklets.set(this.context, {});\n            workletsRecord = registeredWorklets.get(this.context)!;\n        }\n\n        // create new record to fill in as becomes available\n        workletsRecord[workletName] = { handlers: [handler] };\n\n        const src = createWorketFromSrc(workletName, workletSrc);\n        await this.context.audioWorklet.addModule(src);\n        const worklet = new AudioWorkletNode(this.context, workletName);\n\n        //add the node into the map\n        workletsRecord[workletName].node = worklet;\n\n        return this;\n    }\n\n    addPCM16(chunk: Uint8Array) {\n        const float32Array = new Float32Array(chunk.length / 2);\n        const dataView = new DataView(chunk.buffer);\n\n        for (let i = 0; i < chunk.length / 2; i++) {\n            try {\n                const int16 = dataView.getInt16(i * 2, true);\n                float32Array[i] = int16 / 32768;\n            } catch (e) {\n                console.error(e);\n            }\n        }\n\n        const newBuffer = new Float32Array(\n            this.processingBuffer.length + float32Array.length\n        );\n        newBuffer.set(this.processingBuffer);\n        newBuffer.set(float32Array, this.processingBuffer.length);\n        this.processingBuffer = newBuffer;\n\n        while (this.processingBuffer.length >= this.bufferSize) {\n            const buffer = this.processingBuffer.slice(0, this.bufferSize);\n            this.audioQueue.push(buffer);\n            this.processingBuffer = this.processingBuffer.slice(\n                this.bufferSize\n            );\n        }\n\n        if (!this.isPlaying) {\n            this.isPlaying = true;\n            // Initialize scheduledTime only when we start playing\n            this.scheduledTime =\n                this.context.currentTime + this.initialBufferTime;\n            this.scheduleNextBuffer();\n        }\n    }\n\n    private createAudioBuffer(audioData: Float32Array): AudioBuffer {\n        const audioBuffer = this.context.createBuffer(\n            1,\n            audioData.length,\n            this.sampleRate\n        );\n        audioBuffer.getChannelData(0).set(audioData);\n        return audioBuffer;\n    }\n\n    private scheduleNextBuffer() {\n        const SCHEDULE_AHEAD_TIME = 0.2;\n\n        while (\n            this.audioQueue.length > 0 &&\n            this.scheduledTime < this.context.currentTime + SCHEDULE_AHEAD_TIME\n        ) {\n            const audioData = this.audioQueue.shift()!;\n            const audioBuffer = this.createAudioBuffer(audioData);\n            const source = this.context.createBufferSource();\n\n            if (this.audioQueue.length === 0) {\n                if (this.endOfQueueAudioSource) {\n                    this.endOfQueueAudioSource.onended = null;\n                }\n                this.endOfQueueAudioSource = source;\n                source.onended = () => {\n                    if (\n                        !this.audioQueue.length &&\n                        this.endOfQueueAudioSource === source\n                    ) {\n                        this.endOfQueueAudioSource = null;\n                        this.onComplete();\n                    }\n                };\n            }\n\n            source.buffer = audioBuffer;\n            source.connect(this.gainNode);\n\n            const worklets = registeredWorklets.get(this.context);\n\n            if (worklets) {\n                Object.entries(worklets).forEach(([workletName, graph]) => {\n                    const { node, handlers } = graph;\n                    if (node) {\n                        source.connect(node);\n                        node.port.onmessage = function (ev: MessageEvent) {\n                            handlers.forEach((handler) => {\n                                handler.call(node.port, ev);\n                            });\n                        };\n                        node.connect(this.context.destination);\n                    }\n                });\n            }\n\n            // Ensure we never schedule in the past\n            const startTime = Math.max(\n                this.scheduledTime,\n                this.context.currentTime\n            );\n            source.start(startTime);\n\n            this.scheduledTime = startTime + audioBuffer.duration;\n        }\n\n        if (\n            this.audioQueue.length === 0 &&\n            this.processingBuffer.length === 0\n        ) {\n            if (this.isStreamComplete) {\n                this.isPlaying = false;\n                if (this.checkInterval) {\n                    clearInterval(this.checkInterval);\n                    this.checkInterval = null;\n                }\n            } else {\n                if (!this.checkInterval) {\n                    this.checkInterval = window.setInterval(() => {\n                        if (\n                            this.audioQueue.length > 0 ||\n                            this.processingBuffer.length >= this.bufferSize\n                        ) {\n                            this.scheduleNextBuffer();\n                        }\n                    }, 100) as unknown as number;\n                }\n            }\n        } else {\n            const nextCheckTime =\n                (this.scheduledTime - this.context.currentTime) * 1000;\n            setTimeout(\n                () => this.scheduleNextBuffer(),\n                Math.max(0, nextCheckTime - 50)\n            );\n        }\n    }\n\n    stop() {\n        this.isPlaying = false;\n        this.isStreamComplete = true;\n        this.audioQueue = [];\n        this.processingBuffer = new Float32Array(0);\n        this.scheduledTime = this.context.currentTime;\n\n        if (this.checkInterval) {\n            clearInterval(this.checkInterval);\n            this.checkInterval = null;\n        }\n\n        this.gainNode.gain.linearRampToValueAtTime(\n            0,\n            this.context.currentTime + 0.1\n        );\n\n        setTimeout(() => {\n            this.gainNode.disconnect();\n            this.gainNode = this.context.createGain();\n            this.gainNode.connect(this.context.destination);\n        }, 200);\n    }\n\n    async resume() {\n        if (this.context.state === 'suspended') {\n            await this.context.resume();\n        }\n        this.isStreamComplete = false;\n        this.scheduledTime = this.context.currentTime + this.initialBufferTime;\n        this.gainNode.gain.setValueAtTime(1, this.context.currentTime);\n    }\n\n    complete() {\n        this.isStreamComplete = true;\n        if (this.processingBuffer.length > 0) {\n            this.audioQueue.push(this.processingBuffer);\n            this.processingBuffer = new Float32Array(0);\n            if (this.isPlaying) {\n                this.scheduleNextBuffer();\n            }\n        } else {\n            this.onComplete();\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}