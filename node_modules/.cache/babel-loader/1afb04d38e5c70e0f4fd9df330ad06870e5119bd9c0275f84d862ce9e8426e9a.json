{"ast":null,"code":"import { createAudioContext, createWorkletUrl, arrayBufferToBase64 } from './audio-utils.ts';\nimport AudioRecordingWorklet from './worklets/audio-processing';\nimport { EventEmitter } from 'eventemitter3';\nexport class AudioRecorder extends EventEmitter {\n  constructor(sampleRate = 16000) {\n    super();\n    this.sampleRate = sampleRate;\n    this.stream = void 0;\n    this.audioContext = void 0;\n    this.source = void 0;\n    this.recording = false;\n    this.recordingWorklet = void 0;\n    this.starting = null;\n  }\n  async start() {\n    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n      throw new Error('Could not request user media');\n    }\n    this.starting = new Promise(async (resolve, reject) => {\n      try {\n        this.stream = await navigator.mediaDevices.getUserMedia({\n          audio: {\n            sampleRate: this.sampleRate,\n            channelCount: 1,\n            echoCancellation: true,\n            noiseSuppression: true,\n            autoGainControl: true\n          }\n        });\n        this.audioContext = await createAudioContext(this.sampleRate);\n        this.source = this.audioContext.createMediaStreamSource(this.stream);\n        const workletName = 'audio-recording-worklet';\n        const src = createWorkletUrl(AudioRecordingWorklet);\n        await this.audioContext.audioWorklet.addModule(src);\n        this.recordingWorklet = new AudioWorkletNode(this.audioContext, workletName);\n        this.recordingWorklet.port.onmessage = async ev => {\n          // worklet processes recording floats and messages converted buffer\n          const arrayBuffer = ev.data.data.int16arrayBuffer;\n          if (arrayBuffer) {\n            const arrayBufferString = arrayBufferToBase64(arrayBuffer);\n            this.emit('data', arrayBufferString);\n          }\n        };\n        this.source.connect(this.recordingWorklet);\n        this.recording = true;\n        resolve();\n        this.starting = null;\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n  stop() {\n    // its plausible that stop would be called before start completes\n    // such as if the websocket immediately hangs up\n    const handleStop = () => {\n      var _this$source, _this$stream;\n      (_this$source = this.source) === null || _this$source === void 0 ? void 0 : _this$source.disconnect();\n      (_this$stream = this.stream) === null || _this$stream === void 0 ? void 0 : _this$stream.getTracks().forEach(track => track.stop());\n      this.stream = undefined;\n      this.recordingWorklet = undefined;\n      this.recording = false;\n    };\n    if (this.starting) {\n      this.starting.then(handleStop);\n      return;\n    }\n    handleStop();\n  }\n  isRecording() {\n    return this.recording;\n  }\n}","map":{"version":3,"names":["createAudioContext","createWorkletUrl","arrayBufferToBase64","AudioRecordingWorklet","EventEmitter","AudioRecorder","constructor","sampleRate","stream","audioContext","source","recording","recordingWorklet","starting","start","navigator","mediaDevices","getUserMedia","Error","Promise","resolve","reject","audio","channelCount","echoCancellation","noiseSuppression","autoGainControl","createMediaStreamSource","workletName","src","audioWorklet","addModule","AudioWorkletNode","port","onmessage","ev","arrayBuffer","data","int16arrayBuffer","arrayBufferString","emit","connect","error","stop","handleStop","_this$source","_this$stream","disconnect","getTracks","forEach","track","undefined","then","isRecording"],"sources":["/Users/gagandeep.singh/Downloads/trp-main-feature-voice-first-ui/frontend2/src/lib/AudioRecorder.ts"],"sourcesContent":["import { createAudioContext, createWorkletUrl, arrayBufferToBase64 } from './audio-utils.ts';\nimport AudioRecordingWorklet from './worklets/audio-processing';\nimport { EventEmitter } from 'eventemitter3';\n\nexport class AudioRecorder extends EventEmitter {\n  private stream?: MediaStream;\n  private audioContext?: AudioContext;\n  private source?: MediaStreamAudioSourceNode;\n  private recording: boolean = false;\n  private recordingWorklet?: AudioWorkletNode;\n  private starting: Promise<void> | null = null;\n\n  constructor(public sampleRate = 16000) {\n    super();\n  }\n\n  async start() {\n    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n      throw new Error('Could not request user media');\n    }\n\n    this.starting = new Promise(async (resolve, reject) => {\n      try {\n        this.stream = await navigator.mediaDevices.getUserMedia({ \n          audio: {\n            sampleRate: this.sampleRate,\n            channelCount: 1,\n            echoCancellation: true,\n            noiseSuppression: true,\n            autoGainControl: true,\n          }\n        });\n        \n        this.audioContext = await createAudioContext(this.sampleRate);\n        this.source = this.audioContext.createMediaStreamSource(this.stream);\n\n        const workletName = 'audio-recording-worklet';\n        const src = createWorkletUrl(AudioRecordingWorklet);\n\n        await this.audioContext.audioWorklet.addModule(src);\n        this.recordingWorklet = new AudioWorkletNode(\n          this.audioContext,\n          workletName,\n        );\n\n        this.recordingWorklet.port.onmessage = async (ev: MessageEvent) => {\n          // worklet processes recording floats and messages converted buffer\n          const arrayBuffer = ev.data.data.int16arrayBuffer;\n\n          if (arrayBuffer) {\n            const arrayBufferString = arrayBufferToBase64(arrayBuffer);\n            this.emit('data', arrayBufferString);\n          }\n        };\n        \n        this.source.connect(this.recordingWorklet);\n        this.recording = true;\n        resolve();\n        this.starting = null;\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  stop() {\n    // its plausible that stop would be called before start completes\n    // such as if the websocket immediately hangs up\n    const handleStop = () => {\n      this.source?.disconnect();\n      this.stream?.getTracks().forEach((track) => track.stop());\n      this.stream = undefined;\n      this.recordingWorklet = undefined;\n      this.recording = false;\n    };\n    \n    if (this.starting) {\n      this.starting.then(handleStop);\n      return;\n    }\n    handleStop();\n  }\n\n  isRecording(): boolean {\n    return this.recording;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}